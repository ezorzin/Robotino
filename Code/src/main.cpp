/// @file

#define INTEROP       true                                                                           // "true" = use OpenGL-OpenCL interoperability.
#define SX            800                                                                            // Window x-size [px].
#define SY            600                                                                            // Window y-size [px].
#define NM            "Neutrino - Robotino"                                                          // Window name.
#define OX            0.0f                                                                           // x-axis orbit initial rotation.
#define OY            0.0f                                                                           // y-axis orbit initial rotation.
#define PX            0.0f                                                                           // x-axis pan initial translation.
#define PY            0.0f                                                                           // y-axis pan initial translation.
#define PZ            -2.0f                                                                          // z-axis pan initial translation.

#define SURFACE_TAG   2                                                                              // Surface tag.
#define BORDER_TAG    6                                                                              // Border tag.
#define SIDE_X_TAG    7                                                                              // Side "x" tag.
#define SIDE_Y_TAG    8                                                                              // Side "y" tag.
#define SIDE_Z_TAG    9                                                                              // Side "y" tag.
#define SURFACE_DIM   2                                                                              // Surface dimension.
#define BORDER_DIM    1                                                                              // Border dimension.
#define SIDE_X_DIM    1                                                                              // Side "x" dimension.
#define SIDE_Y_DIM    1                                                                              // Side "y" dimension.
#define SIDE_Z_DIM    1                                                                              // Side "z" dimension.
#define DS            0.01                                                                           // ground elementary cell side.
#define EPSILON       0.001                                                                          // Tolerance for cell detection.
#define CELL_VERTICES 8                                                                              // Number of vertices per elementary cell.

#ifdef __linux__
  #define SHADER_HOME "../../Code/shader/"                                                           // Linux OpenGL shaders directory.
  #define KERNEL_HOME "../../Code/kernel/"                                                           // Linux OpenCL kernels directory.
  #define GMSH_HOME   "../../Code/mesh/"                                                             // Linux GMSH mesh directory.
#endif

#ifdef WIN32
  #define SHADER_HOME "..\\..\\Code\\shader\\"                                                       // Windows OpenGL shaders directory.
  #define KERNEL_HOME "..\\..\\Code\\kernel\\"                                                       // Windows OpenCL kernels directory.
  #define GMSH_HOME   "..\\..\\Code\\mesh\\"                                                         // Linux GMSH mesh directory.
#endif

#define SHADER_VERT   "voxel_vertex.vert"                                                            // OpenGL vertex shader.
#define SHADER_GEOM   "voxel_geometry.geom"                                                          // OpenGL geometry shader.
#define SHADER_FRAG   "voxel_fragment.frag"                                                          // OpenGL fragment shader.
#define KERNEL_1      "thekernel_1.cl"                                                               // OpenCL kernel source.
#define KERNEL_2      "thekernel_2.cl"                                                               // OpenCL kernel source.
#define UTILITIES     "utilities.cl"                                                                 // OpenCL utilities source.
#define GROUND_FILE   "Ground.msh"                                                                   // Ground mesh.
#define GROUND_MESH   GMSH_HOME GROUND_FILE                                                          // Ground mesh (full path).
#define BODY_FILE     "Body.msh"                                                                     // Body mesh.
#define BODY_MESH     GMSH_HOME BODY_FILE                                                            // Body mesh (full path).

// INCLUDES:
#include "nu.hpp"                                                                                    // Neutrino's header file.

int main ()
{
  // INDICES:
  size_t                           i;                                                                // Index [#].
  size_t                           j;                                                                // Index [#].
  size_t                           j_min;                                                            // Index [#].
  size_t                           j_max;                                                            // Index [#].

  // MOUSE PARAMETERS:
  float                            ms_orbit_rate  = 1.0f;                                            // Orbit rotation rate [rev/s].
  float                            ms_pan_rate    = 5.0f;                                            // Pan translation rate [m/s].
  float                            ms_decaytime   = 1.25f;                                           // Pan LP filter decay time [s].

  // GAMEPAD PARAMETERS:
  float                            gmp_orbit_rate = 1.0f;                                            // Orbit angular rate coefficient [rev/s].
  float                            gmp_pan_rate   = 1.0f;                                            // Pan translation rate [m/s].
  float                            gmp_decaytime  = 1.25f;                                           // Low pass filter decay time [s].
  float                            gmp_deadzone   = 0.30f;                                           // Gamepad joystick deadzone [0...1].

  // OPENGL:
  nu::opengl*                      gl             = new nu::opengl (NM, SX, SY, OX, OY, PX, PY, PZ); // OpenGL context.
  nu::shader*                      S              = new nu::shader ();                               // OpenGL shader program.
  nu::projection_mode              proj_mode      = nu::MONOCULAR;                                   // OpenGL projection mode.

  // OPENCL:
  nu::opencl*                      cl             = new nu::opencl (nu::GPU);                        // OpenCL context.
  nu::kernel*                      K1             = new nu::kernel ();                               // OpenCL kernel array.
  nu::kernel*                      K2             = new nu::kernel ();                               // OpenCL kernel array.
  nu::float4*                      body_col       = new nu::float4 (0);                              // Color [].
  nu::float4*                      body_pos       = new nu::float4 (1);                              // Position [m].
  nu::float4*                      body_vel       = new nu::float4 (2);                              // Velocity [m/s].
  nu::float4*                      body_acc       = new nu::float4 (3);                              // Acceleration [m/s^2].
  nu::float4*                      body_pos_int   = new nu::float4 (4);                              // Position (intermediate) [m].
  nu::float4*                      body_vel_int   = new nu::float4 (5);                              // Velocity (intermediate) [m/s].
  nu::float1*                      body_rest      = new nu::float1 (6);                              // Resting.
  nu::int1*                        body_cen       = new nu::int1 (7);                                // Central nodes.
  nu::int1*                        body_neigh     = new nu::int1 (8);                                // Neighbour.
  nu::int1*                        body_ofs       = new nu::int1 (9);                                // Offset.
  nu::float1*                      body_param     = new nu::float1 (10);                             // Resting.

  // IMGUI:
  nu::imgui*                       hud            = new nu::imgui ();                                // ImGui context.

  // GROUND MESH:
  nu::mesh*                        ground_mesh    = new nu::mesh (GROUND_MESH);                      // Ground mesh.
  size_t                           ground_nodes;                                                     // Number of nodes.
  size_t                           ground_elements;                                                  // Number of elements.
  size_t                           ground_groups;                                                    // Number of groups.
  size_t                           ground_neighbours;                                                // Number of neighbours.
  std::vector<size_t>              ground_side_x;                                                    // Nodes on "x" side.
  std::vector<size_t>              ground_side_y;                                                    // Nodes on "y" side.
  std::vector<GLint>               ground_border;                                                    // Nodes on border.
  size_t                           ground_x_nodes;                                                   // Number of nodes in "x" direction [#].
  size_t                           ground_y_nodes;                                                   // Number of nodes in "x" direction [#].
  size_t                           ground_border_nodes;                                              // Number of border nodes.

  // BODY MESH:
  nu::mesh*                        body_mesh = new nu::mesh (BODY_MESH);                             // Body mesh.
  size_t                           body_nodes;                                                       // Number of nodes.
  size_t                           body_elements;                                                    // Number of elements.
  size_t                           body_groups;                                                      // Number of groups.
  size_t                           body_neighbours;                                                  // Number of neighbours.
  std::vector<size_t>              body_side_x;                                                      // Nodes on "x" side.
  std::vector<size_t>              body_side_y;                                                      // Nodes on "y" side.
  std::vector<GLint>               body_border;                                                      // Nodes on border.
  size_t                           body_x_nodes;                                                     // Number of nodes in "x" direction [#].
  size_t                           body_y_nodes;                                                     // Number of nodes in "y" direction [#].
  size_t                           body_z_nodes;                                                     // Number of nodes in "z" direction [#].
  size_t                           body_border_nodes;                                                // Number of border nodes.
  int                              BODY_VOLUME = 1;                                                  // Entire volume.

  // SIMULATION PARAMETERS:
  float                            g           = 9.81f;                                              // External gravity field [m/s^2].
  float                            m           = 1.0f;                                               // Body node mass [kg].
  float                            K           = 100.0f;                                             // Body elastic constant [N/m].
  float                            B           = 1.0f;                                               // Body damping [N/(m/s)].
  float                            dt_critical;                                                      // Critical time step [s].
  float                            dt_simulation;                                                    // Simulation time step [s].

  // BACKUP:
  std::vector<nu_float4_structure> body_init_pos;                                                    // Backing up initial data...
  std::vector<nu_float4_structure> body_init_pos_int;                                                // Backing up initial data...
  std::vector<nu_float4_structure> body_init_vel;                                                    // Backing up initial data...
  std::vector<nu_float4_structure> body_init_vel_int;                                                // Backing up initial data...
  std::vector<nu_float4_structure> body_init_acc;                                                    // Backing up initial data...

  /////////////////////////////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////// DATA INITIALIZATION ///////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////
  // COMPUTING PHYSICAL PARAMETERS:
  dt_critical        = sqrt (m/K);                                                                   // Critical time step [s].
  dt_simulation      = 0.5f*dt_critical;                                                             // Simulation time step [s].
  body_param->data.push_back (g);                                                                    // Setting gravity...
  body_param->data.push_back (m);                                                                    // Setting mass...
  body_param->data.push_back (K);                                                                    // Setting stiffness...
  body_param->data.push_back (B);                                                                    // Setting damping...
  body_param->data.push_back (dt_simulation);                                                        // Setting damping...

  // BODY MESH:
  body_mesh->process (BODY_VOLUME, 3, nu::MSH_HEX_8);                                                // Processing mesh...
  body_pos->data     = body_mesh->node_coordinates;                                                  // Setting all node coordinates...
  body_pos_int->data = body_mesh->node_coordinates;                                                  // Setting all node coordinates...
  body_neigh->data   = body_mesh->neighbour;                                                         // Setting neighbour indices...
  body_ofs->data     = body_mesh->neighbour_offset;                                                  // Setting neighbour offsets...
  body_rest->data    = body_mesh->neighbour_length;                                                  // Setting resting distances...
  body_nodes         = body_mesh->node.size ();                                                      // Getting the number of nodes...
  body_elements      = body_mesh->element.size ();                                                   // Getting the number of elements...
  body_groups        = body_mesh->group.size ();                                                     // Getting the number of groups...
  body_neighbours    = body_mesh->neighbour.size ();                                                 // Getting the number of neighbours...
  std::cout << "body nodes = " << body_nodes << std::endl;                                           // Printing message...
  std::cout << "body elements = " << body_elements/CELL_VERTICES << std::endl;                       // Printing message...
  std::cout << "body groups = " << body_groups/CELL_VERTICES << std::endl;                           // Printing message...
  std::cout << "body neighbours = " << body_neighbours << std::endl;                                 // Printing message...

  // SETTING BODY ARRAYS ("nodes" depending):
  for(i = 0; i < body_nodes; i++)
  {
    std::cout << "i = " << i << ", node index = " << body_mesh->node[i] << ", neighbour indices:";   // Printing message...
    body_pos->data[i]     = {body_pos->data[i].x + 0.0f,
                             body_pos->data[i].y + 0.0f,
                             body_pos->data[i].z + 1.0f,
                             1.0f};                                                                  // Setting initial position...
    body_pos_int->data[i] = {body_pos->data[i].x + 0.0f,
                             body_pos->data[i].y + 0.0f,
                             body_pos->data[i].z + 1.0f,
                             1.0f};                                                                  // Setting initial intermediate position...
    body_vel->data.push_back ({0.0f, 0.0f, 0.0f, 1.0f});                                             // Setting initial velocity...
    body_vel_int->data.push_back ({0.0f, 0.0f, 0.0f, 1.0f});                                         // Setting initial intermediate velocity...
    body_acc->data.push_back ({0.0f, 0.0f, 0.0f, 1.0f});                                             // Setting initial acceleration...

    // Computing minimum element offset index:
    if(i == 0)
    {
      j_min = 0;                                                                                     // Setting minimum element offset index...
    }
    else
    {
      j_min = body_ofs->data[i - 1];                                                                 // Setting minimum element offset index...
    }

    j_max = body_ofs->data[i];                                                                       // Setting maximum element offset index...

    for(j = j_min; j < j_max; j++)
    {
      body_cen->data.push_back (body_mesh->node[i]);                                                 // Building central node tuple...

      std::cout << " " << body_neigh->data[j];                                                       // Printing message...

      if(body_rest->data[j] > (DS + EPSILON))
      {
        body_col->data.push_back ({1.0f, 0.0f, 0.0f, 0.1f});                                         // Setting link color...
      }
      else
      {
        body_col->data.push_back ({0.0f, 1.0f, 0.0f, 1.0f});                                         // Setting link color...
      }
    }

    std::cout << std::endl;                                                                          // Printing message...
  }

  // SETTING INITIAL DATA BACKUP:
  body_init_pos     = body_pos->data;                                                                // Setting backup data...
  body_init_pos_int = body_pos_int->data;                                                            // Setting backup data...
  body_init_vel     = body_vel->data;                                                                // Setting backup data...
  body_init_vel_int = body_vel_int->data;                                                            // Setting backup data...
  body_init_acc     = body_acc->data;                                                                // Setting backup data...

  /////////////////////////////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////// OPENCL KERNELS INITIALIZATION //////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////
  K1->addsource (std::string (KERNEL_HOME) + std::string (UTILITIES));                               // Setting kernel source file...
  K1->addsource (std::string (KERNEL_HOME) + std::string (KERNEL_1));                                // Setting kernel source file...
  K1->build (body_nodes, 0, 0);                                                                      // Building kernel program...
  K2->addsource (std::string (KERNEL_HOME) + std::string (UTILITIES));                               // Setting kernel source file...
  K2->addsource (std::string (KERNEL_HOME) + std::string (KERNEL_2));                                // Setting kernel source file...
  K2->build (body_nodes, 0, 0);                                                                      // Building kernel program...

  /////////////////////////////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////// OPENGL SHADERS INITIALIZATION //////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////
  S->addsource (std::string (SHADER_HOME) + std::string (SHADER_VERT), nu::VERTEX);                  // Setting shader source file...
  S->addsource (std::string (SHADER_HOME) + std::string (SHADER_GEOM), nu::GEOMETRY);                // Setting shader source file...
  S->addsource (std::string (SHADER_HOME) + std::string (SHADER_FRAG), nu::FRAGMENT);                // Setting shader source file...
  S->build (body_neighbours);                                                                        // Building shader program...

  /////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////// SETTING OPENCL KERNEL ARGUMENTS //////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////
  cl->write ();                                                                                      // Writing OpenCL data...

  /////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////// APPLICATION LOOP /////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////
  while(!gl->closed ())                                                                              // Opening window...
  {
    cl->get_tic ();                                                                                  // Getting "tic" [us]...
    cl->acquire ();                                                                                  // Acquiring OpenCL kernel...
    cl->execute (K1, nu::WAIT);                                                                      // Executing OpenCL kernel...
    cl->execute (K2, nu::WAIT);                                                                      // Executing OpenCL kernel...
    cl->release ();                                                                                  // Releasing OpenCL kernel...

    gl->begin ();                                                                                    // Beginning gl...
    gl->poll_events ();                                                                              // Polling gl events...
    gl->mouse_navigation (ms_orbit_rate, ms_pan_rate, ms_decaytime);                                 // Polling mouse...
    gl->gamepad_navigation (gmp_orbit_rate, gmp_pan_rate, gmp_decaytime, gmp_deadzone);              // Polling gamepad...
    gl->plot (S, proj_mode);                                                                         // Plotting shared arguments...

    hud->begin ();                                                                                   // Beginning HUD...
    hud->window ("FREE LATTICE PARAMETERS", 200);                                                    // Creating window...
    hud->input ("Mass:            ", "[kg]     ", "m", &m);                                          // Adding input parameter...
    hud->input ("Stiffness:       ", "[N/m]    ", "K", &K);                                          // Adding input parameter...
    hud->input ("Friction :       ", "[N/(m/s)]", "B", &B);                                          // Adding input parameter...
    hud->input ("Gravity:         ", "[m/s^2]  ", "g", &g);                                          // Adding input parameter...

    if(hud->button ("(U)pdate", 100) || gl->key_U)
    {
      // RECOMPUTING PHYSICAL PARAMETERS:
      dt_critical         = sqrt (m/K);                                                              // Critical time step [s].
      dt_simulation       = 0.5f*dt_critical;                                                        // Simulation time step [s].
      body_param->data[0] = dt_simulation;                                                           // Setting simulation time step...
      body_param->data[1] = g;                                                                       // Setting gravity...
      body_param->data[2] = m;                                                                       // Setting mass...
      body_param->data[3] = K;                                                                       // Setting stiffness...
      body_param->data[4] = B;                                                                       // Setting damping...
      cl->write (10);                                                                                // Writing body parameters...
    }

    hud->space (50);                                                                                 // Setting spacing...

    if(hud->button ("(R)estart", 100) || gl->button_TRIANGLE || gl->key_R)
    {
      body_pos->data     = body_init_pos;                                                            // Restoring backup...
      body_pos_int->data = body_init_pos_int;                                                        // Restoring backup...
      body_vel->data     = body_init_vel;                                                            // Restoring backup...
      body_vel_int->data = body_init_vel_int;                                                        // Restoring backup...
      body_acc->data     = body_init_acc;                                                            // Restoring backup...
      cl->write (1);                                                                                 // Writing data...
      cl->write (2);                                                                                 // Writing data...
      cl->write (3);                                                                                 // Writing data...
      cl->write (4);                                                                                 // Writing data...
      cl->write (5);                                                                                 // Writing data...
    }

    hud->space (50);                                                                                 // Setting spacing...

    if(hud->button ("(M)onocular", 100) || gl->key_M)
    {
      proj_mode = nu::MONOCULAR;                                                                     // Setting monocular projection...
    }

    hud->space (50);                                                                                 // Setting spacing...
    if(hud->button ("(B)inocular", 100) || gl->key_B)
    {
      proj_mode = nu::BINOCULAR;                                                                     // Setting binocular projection...
    }

    hud->space (50);                                                                                 // Setting spacing...

    if(hud->button ("(E)xit", 100) || gl->button_CIRCLE || gl->key_E)
    {
      gl->close ();                                                                                  // Closing gl...
    }

    hud->finish ();                                                                                  // Finishing window...
    hud->end ();                                                                                     // Ending HUD...

    gl->end ();                                                                                      // Ending gl...

    cl->get_toc ();                                                                                  // Getting "toc" [us]...
  }

  /////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////// CLEANUP /////////////////////////////////////////////
  /////////////////////////////////////////////////////////////////////////////////////////////////////
  delete cl;                                                                                         // Deleting OpenCL context...
  delete gl;                                                                                         // Deleting OpenGL context...
  delete hud;                                                                                        // Deleting HUD context...
  delete S;                                                                                          // Deleting shader...
  delete body_col;                                                                                   // Deleting color data...
  delete body_pos;                                                                                   // Deleting position data...
  delete body_pos_int;                                                                               // Deleting intermediate position data...
  delete body_vel;                                                                                   // Deleting velocity data...
  delete body_vel_int;                                                                               // Deleting intermediate velocity data...
  delete body_acc;                                                                                   // Deleting acceleration data...
  delete body_rest;                                                                                  // Deleting resting data...
  delete body_cen;                                                                                   // Deleting centrals...
  delete body_neigh;                                                                                 // Deleting neighbours...
  delete body_ofs;                                                                                   // Deleting offset...
  delete body_param;                                                                                 // Deleting parameters data...
  delete K1;                                                                                         // Deleting OpenCL kernel...
  delete K2;                                                                                         // Deleting OpenCL kernel...
  //delete ground_mesh;                                                                                // Deleting ground mesh...
  delete body_mesh;                                                                                  // Deleting body mesh...
  return 0;
}
